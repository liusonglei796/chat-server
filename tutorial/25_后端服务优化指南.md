# Go 后端服务优化指南

本文档总结了在重构 `GroupService` 过程中应用的优化策略，可作为后续优化其他服务的参考手册。

---

## 一、数据库操作优化

### 1.1 事务管理 (Transaction)

**问题**：多个数据库写操作没有包裹在事务中，导致部分失败时数据不一致。

**优化前**：
```go
// ❌ 没有事务，如果第二步失败，第一步的数据已落库
g.repos.GroupMember.Delete(groupId, userId)
g.repos.Group.DecrementMemberCount(groupId) // 失败了！
g.repos.Contact.SoftDelete(userId, groupId)
```

**优化后**：
```go
// ✅ 任何一步失败，整体回滚
err := g.repos.Transaction(func(txRepos *mysql.Repositories) error {
    if err := txRepos.GroupMember.Delete(groupId, userId); err != nil {
        return err
    }
    if err := txRepos.Group.DecrementMemberCount(groupId); err != nil {
        return err
    }
    if err := txRepos.Contact.SoftDelete(userId, groupId); err != nil {
        return err
    }
    return nil
})
```

**适用场景**：任何涉及多表写操作的业务逻辑。

---

### 1.2 批量操作 (Batch Operations)

**问题**：循环中逐条执行 SQL，产生 N+1 查询问题。

**优化前**：
```go
// ❌ N+1 问题：循环 10 次 = 10 条 SQL
for range req.UuidList {
    g.repos.Group.DecrementMemberCount(groupId) // 每次 UPDATE ... SET cnt = cnt - 1
}
```

**优化后**：
```go
// ✅ 只执行 1 条 SQL：UPDATE ... SET cnt = cnt - 10
g.repos.Group.DecrementMemberCountBy(groupId, len(req.UuidList))
```

**常见模式**：
| 原始方法 | 批量方法 |
|---------|---------|
| `Delete(id)` 循环 | `DeleteByIds([]string)` |
| `FindByUuid(id)` 循环 | `FindByUuids([]string)` |
| `Update(obj)` 循环 | `UpdateByCondition(condition, updates)` |

---

### 1.3 分页查询 (Pagination)

**问题**：`FindAll()` 查询全部数据，数据量大时 OOM。

**优化前**：
```go
// ❌ 如果有 10 万条数据，全部加载到内存
groups, _ := g.repos.Group.FindAll()
```

**优化后**：
```go
// ✅ 分页加载，每次只取 20 条
groups, total, _ := g.repos.Group.GetList(page, pageSize)
return &respond.Wrapper{List: groups, Total: total}
```

**实现要点**：
```go
func (r *repo) GetList(page, pageSize int) ([]Model, int64, error) {
    var list []Model
    var total int64
    offset := (page - 1) * pageSize
    
    r.db.Model(&Model{}).Count(&total)
    r.db.Offset(offset).Limit(pageSize).Find(&list)
    
    return list, total, nil
}
```

---

## 二、缓存策略优化

### 2.1 Cache-Aside 模式

**问题**：缓存未命中后不回写，导致缓存永远为空（穿透）。

**优化前**：
```go
// ❌ 查库后没有回写缓存
data, err := redis.Get(key)
if err == redis.Nil {
    data, _ = db.Find(id)
    return data // 下次还是 Miss！
}
```

**优化后**：
```go
// ✅ 完整的 Cache-Aside 模式
data, err := redis.Get(key)
if err == nil {
    return unmarshal(data) // 1. 命中直接返回
}
if err != redis.Nil {
    log.Error(err) // 2. Redis 异常，降级查库
}

result, _ := db.Find(id) // 3. 查库

go func() { // 4. 异步回写
    redis.SetEx(key, marshal(result), 24*time.Hour)
}()

return result
```

---

### 2.2 精确缓存清理 vs 核弹清理

**问题**：使用 `DelKeysWithPrefix("user_")` 清理所有用户缓存，影响无关用户。

**优化前**：
```go
// ❌ 核弹级清理：删除所有用户的缓存
redis.DelKeysWithPrefix("my_joined_group_list") // 影响全站用户！
```

**优化后**：
```go
// ✅ 精确清理：只删除涉事用户的缓存
for _, memberId := range affectedMemberIds {
    redis.Del("my_joined_group_list_" + memberId)
}
```

**实现要点**：
1. 在事务执行**之前**收集需要清理的 Key（用户 ID、群组 ID 等）。
2. 在事务成功**之后**异步清理这些 Key。

---

### 2.3 异步缓存操作

**问题**：同步清理缓存阻塞主流程。

**优化前**：
```go
// ❌ 缓存操作阻塞主流程
redis.Del("group_info_" + groupId)
return nil
```

**优化后**：
```go
// ✅ 异步清理，不阻塞响应
go func() {
    redis.Del("group_info_" + groupId)
}()
return nil
```

---

## 三、并发与性能优化

### 3.1 Slice 预分配

**问题**：`append` 导致频繁内存重分配。

**优化前**：
```go
// ❌ 初始容量为 0，每次扩容都要复制数据
var result []Item
for _, item := range list {
    result = append(result, transform(item))
}
```

**优化后**：
```go
// ✅ 预分配容量，避免扩容
result := make([]Item, 0, len(list))
for _, item := range list {
    result = append(result, transform(item))
}
```

---

### 3.2 移除调试代码

**问题**：生产代码中残留 `log.Println` 或 `fmt.Println`。

```go
// ❌ 调试代码
log.Println(req.UuidList, req.OwnerId)

// ✅ 使用结构化日志（如果需要）
zap.L().Debug("RemoveGroupMembers", zap.Strings("uuids", req.UuidList))
```

---

## 四、代码风格优化

### 4.1 简化布尔赋值

**优化前**：
```go
if group.DeletedAt.Valid {
    rsp.IsDeleted = true
} else {
    rsp.IsDeleted = false
}
```

**优化后**：
```go
rsp.IsDeleted = group.DeletedAt.Valid
```

---

### 4.2 提取缓存 Key

**优化前**：
```go
redis.Get("group_info_" + groupId)
// ... 很多代码 ...
redis.Set("group_info_" + groupId, data)
```

**优化后**：
```go
cacheKey := "group_info_" + groupId
redis.Get(cacheKey)
// ...
redis.Set(cacheKey, data)
```

---

## 五、检查清单

在审查或编写 Service 层代码时，逐项检查：

- [ ] **事务**：多表写操作是否包裹在 `Transaction` 中？
- [ ] **批量**：是否存在循环中执行 SQL 的 N+1 问题？
- [ ] **分页**：`FindAll` 类查询是否需要分页？
- [ ] **缓存读**：是否实现了 Cache-Aside（回写）？
- [ ] **缓存写**：是否使用精确清理而非前缀清理？
- [ ] **缓存异步**：缓存操作是否放在 `go func()` 中？
- [ ] **预分配**：`make([]T, 0, len)` 是否使用？
- [ ] **调试代码**：是否移除了 `log.Println` / `fmt.Println`？
- [ ] **代码风格**：布尔赋值、Key 提取等是否简洁？
