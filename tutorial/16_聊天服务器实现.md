# 16. èŠå¤©æœåŠ¡å™¨å®ç°

> æœ¬ç« ä»¥å½“å‰ä»£ç ä¸ºå‡†ï¼Œè§£é‡ŠèŠå¤©å­ç³»ç»Ÿå¦‚ä½•é€šè¿‡ `ChatServer` èšåˆå¹¶é€‰æ‹© `MessageBroker`ï¼Œä»¥åŠ Channel æ¨¡å¼ä¸‹ `StandaloneServer` å¦‚ä½•ç®¡ç†åœ¨çº¿è¿æ¥ä¸æ¶ˆæ¯æ¶ˆè´¹å¾ªç¯ã€‚

---

## ğŸ“Œ å­¦ä¹ ç›®æ ‡

- ç†è§£ `ChatServer` çš„èŒè´£ï¼šæŒ‰é…ç½®é€‰æ‹© Channel/Kafka Broker
- ç†è§£ `MessageBroker` æ¥å£å¯¹ WebSocket ç½‘å…³çš„è§£è€¦ä½œç”¨
- æŒæ¡ Channel æ¨¡å¼ `StandaloneServer` çš„ Login/Logout/Transmit å¹¶å‘æ¨¡å‹
- ç†è§£ä¾èµ–æ³¨å…¥ï¼šRepository/CacheService å¦‚ä½•ä¼ å…¥ Broker

---

## 1. ä»£ç ä½ç½®ï¼ˆä»¥å½“å‰å®ç°ä¸ºå‡†ï¼‰

- æœåŠ¡å™¨èšåˆä¸ Broker é€‰æ‹©ï¼š`internal/service/chat/server.go`
- Channel æ¨¡å¼ Brokerï¼š`internal/service/chat/channel_broker.go`
- Kafka æ¨¡å¼ Brokerï¼š`internal/service/chat/kafka_broker.go`

> æ³¨æ„ï¼šæœ¬é¡¹ç›®çš„ Channel Broker æ–‡ä»¶åä¸º `channel_broker.go`ï¼Œä½†æ–‡ä»¶å¤´æ³¨é‡Šé‡Œä»å¯èƒ½å‡ºç° â€œchannel_server.goâ€ å­—æ ·ï¼›ä»¥çœŸå®è·¯å¾„ä¸ºå‡†ã€‚

---

## 2. MessageBrokerï¼šç»Ÿä¸€æŠ½è±¡

WebSocket ç½‘å…³åªä¾èµ– `MessageBroker`ï¼Œä¸å…³å¿ƒåº•å±‚æ˜¯ Channel è¿˜æ˜¯ Kafkaã€‚

```go
// internal/service/chat/server.go

type MessageBroker interface {
    Publish(ctx context.Context, msg []byte) error
    RegisterClient(client *UserConn)
    UnregisterClient(client *UserConn)
    GetClient(userId string) *UserConn
    Start()
    Close()

    // ä¾› ws_gateway.go åœ¨ Write() ä¸­æ›´æ–°æ¶ˆæ¯çŠ¶æ€
    GetMessageRepo() repository.MessageRepository
}
```

---

## 3. ChatServerï¼šèšåˆä¸æ¨¡å¼é€‰æ‹©

`ChatServer` çš„èŒè´£æ˜¯ï¼š

1. æ¥æ”¶é…ç½®ä¸ä¾èµ–ï¼ˆMessageRepoã€GroupMemberRepoã€CacheServiceï¼‰
2. æ ¹æ® `Mode` é€‰æ‹©åˆ›å»º Channel æˆ– Kafka Broker
3. æä¾›ç»Ÿä¸€çš„ `Run()/Shutdown()` ç”Ÿå‘½å‘¨æœŸ

```go
// internal/service/chat/server.go

type ChatServer struct {
    Broker          MessageBroker
    KafkaClient     *KafkaClient
    messageRepo     repository.MessageRepository
    groupMemberRepo repository.GroupMemberRepository
    cacheService    myredis.AsyncCacheService
    mode            string
}

type ChatServerConfig struct {
    Mode            string
    MessageRepo     repository.MessageRepository
    GroupMemberRepo repository.GroupMemberRepository
    CacheService    myredis.AsyncCacheService
    KafkaHostPort   string
    KafkaTopic      string
}

func NewChatServer(cfg ChatServerConfig) *ChatServer {
    cs := &ChatServer{
        messageRepo:     cfg.MessageRepo,
        groupMemberRepo: cfg.GroupMemberRepo,
        cacheService:    cfg.CacheService,
        mode:            cfg.Mode,
    }

    if cfg.Mode == "kafka" {
        cs.KafkaClient = NewKafkaClient()
        cs.Broker = NewMsgConsumer(cs.KafkaClient, cs.messageRepo, cs.groupMemberRepo, cs.cacheService)
    } else {
        cs.Broker = NewStandaloneServer(cs.messageRepo, cs.groupMemberRepo, cs.cacheService)
    }

    return cs
}
```

---

## 4. Channel æ¨¡å¼ï¼šStandaloneServer ç»“æ„ä¸ä¾èµ–æ³¨å…¥

Channel æ¨¡å¼ Broker ç»“æ„ä½“ä¸º `StandaloneServer`ï¼š

```go
// internal/service/chat/channel_broker.go

type StandaloneServer struct {
    Clients  sync.Map
    Transmit chan []byte
    Login    chan *UserConn
    Logout   chan *UserConn

    // ä¾èµ–æ³¨å…¥ï¼ˆéµå¾ªä¾èµ–å€’ç½®ï¼‰
    messageRepo     repository.MessageRepository
    groupMemberRepo repository.GroupMemberRepository
    cacheService    myredis.AsyncCacheService
}

func NewStandaloneServer(
    messageRepo repository.MessageRepository,
    groupMemberRepo repository.GroupMemberRepository,
    cacheService myredis.AsyncCacheService,
) *StandaloneServer {
    return &StandaloneServer{
        Transmit:        make(chan []byte, constants.CHANNEL_SIZE),
        Login:           make(chan *UserConn, constants.CHANNEL_SIZE),
        Logout:          make(chan *UserConn, constants.CHANNEL_SIZE),
        messageRepo:     messageRepo,
        groupMemberRepo: groupMemberRepo,
        cacheService:    cacheService,
    }
}
```

è®¾è®¡è¦ç‚¹ï¼š

- åœ¨çº¿è¡¨ä½¿ç”¨ `sync.Map`ï¼Œè¯»å†™å¹¶å‘å®‰å…¨
- ä¸šåŠ¡ä¾§ä¸è¦ç›´æ¥ä¾èµ– Gorm/Redis å…·ä½“å®ç°ï¼Œè€Œé€šè¿‡ Repository + CacheService æ³¨å…¥

---

## 5. Startï¼šLogin/Logout/Transmit ä¸‰è·¯å¤ç”¨

`Start()` æ˜¯ Channel æ¨¡å¼çš„æ ¸å¿ƒäº‹ä»¶å¾ªç¯ï¼š

```go
// internal/service/chat/channel_broker.go

func (s *StandaloneServer) Start() {
    for {
        select {
        case client, ok := <-s.Login:
            if !ok {
                return
            }
            if client == nil {
                continue
            }
            s.Clients.Store(client.Uuid, client)
            _ = client.Conn.WriteMessage(websocket.TextMessage, []byte("æ¬¢è¿æ¥åˆ°kamaèŠå¤©æœåŠ¡å™¨"))

        case client, ok := <-s.Logout:
            if !ok {
                return
            }
            if client == nil {
                continue
            }
            s.Clients.Delete(client.Uuid)
            _ = client.Conn.WriteMessage(websocket.TextMessage, []byte("å·²é€€å‡ºç™»å½•"))

        case data, ok := <-s.Transmit:
            if !ok {
                return
            }

            var req request.ChatMessageRequest
            if err := json.Unmarshal(data, &req); err != nil {
                continue
            }

            switch req.Type {
            case message_type_enum.Text:
                s.handleTextMessage(req)
            case message_type_enum.File:
                s.handleFileMessage(req)
            case message_type_enum.AudioOrVideo:
                s.handleAVMessage(req)
            }
        }
    }
}
```

---

## 6. Broker æ¥å£æ–¹æ³•æ˜ å°„

Channel æ¨¡å¼å®ç°äº† `MessageBroker`ï¼š

```go
func (s *StandaloneServer) Publish(ctx context.Context, msg []byte) error {
    s.Transmit <- msg
    return nil
}

func (s *StandaloneServer) RegisterClient(client *UserConn) {
    s.Login <- client
}

func (s *StandaloneServer) UnregisterClient(client *UserConn) {
    s.Logout <- client
}

func (s *StandaloneServer) GetClient(userId string) *UserConn {
    value, ok := s.Clients.Load(userId)
    if !ok {
        return nil
    }
    return value.(*UserConn)
}

func (s *StandaloneServer) Close() {
    close(s.Login)
    close(s.Logout)
    close(s.Transmit)
}
```

---

## 7. åœ¨ main.go ä¸­å¯åŠ¨

é¡¹ç›®å¯åŠ¨æ—¶åˆ›å»º `ChatServer`ï¼Œæ³¨å…¥ Broker åˆ° `WsHandler`ï¼Œå¹¶å¯åŠ¨ `chatServer.Run()`ï¼š

```go
chatServer := chat.NewChatServer(chat.ChatServerConfig{
    Mode:            conf.KafkaConfig.MessageMode,
    MessageRepo:     repos.Message,
    GroupMemberRepo: repos.GroupMember,
    CacheService:    cacheService,
})
if conf.KafkaConfig.MessageMode == "kafka" {
    chatServer.InitKafka()
}
handlers := handler.NewHandlers(services, chatServer.GetBroker())
go chatServer.Run()
```

---

## âœ… æœ¬èŠ‚å°ç»“

- `ChatServer` è´Ÿè´£â€œé€‰æ‹©å¹¶ç®¡ç†â€ Brokerï¼ˆChannel/Kafkaï¼‰
- `StandaloneServer`ï¼ˆChannel æ¨¡å¼ï¼‰ç”¨ä¸‰é€šé“æ¨¡å‹ä¸²èµ·ç™»å½•/ç™»å‡º/æ¶ˆæ¯æ¶ˆè´¹
- Repo/CacheService é€šè¿‡ä¾èµ–æ³¨å…¥è¿›å…¥ Brokerï¼Œé¿å…åœ¨ä¸šåŠ¡é‡Œç¡¬ç¼–ç å…·ä½“å­˜å‚¨å®ç°

ä¸‹ä¸€ç« è¿›å…¥æ¶ˆæ¯å¤„ç†ç»†èŠ‚ï¼šå•èŠ/ç¾¤èŠçš„å…¥åº“ã€è½¬å‘ã€ä»¥åŠ Redis ç¼“å­˜æ›´æ–°ç­–ç•¥ã€‚
