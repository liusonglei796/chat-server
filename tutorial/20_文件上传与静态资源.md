# 20. æ–‡ä»¶ä¸Šä¼ ä¸é™æ€èµ„æº

> æœ¬æ•™ç¨‹å°†å®ç°ç”¨æˆ·å¤´åƒå’ŒèŠå¤©æ–‡ä»¶çš„ä¸Šä¼ åŠŸèƒ½ï¼Œå¹¶é…ç½®é™æ€èµ„æºæœåŠ¡ã€‚

---

## ğŸ“Œ å­¦ä¹ ç›®æ ‡

- ä½¿ç”¨ Gin å¤„ç†æ–‡ä»¶ä¸Šä¼ 
- å®‰å…¨åœ°ä¿å­˜æ–‡ä»¶ï¼ˆMIME æ ¡éªŒã€é‡å‘½åï¼‰
- é…ç½®é™æ€èµ„æºè®¿é—®
- ç†è§£ä¾èµ–æ³¨å…¥æ¨¡å¼åœ¨æ–‡ä»¶æœåŠ¡ä¸­çš„åº”ç”¨
- è¿”å›æ–°ç”Ÿæˆçš„æ–‡ä»¶åä¾›å‰ç«¯ä½¿ç”¨

---

## 1. é™æ€èµ„æºé…ç½®

### 1.1 internal/https_server/https_server.go

```go
package https_server

import (
	"kama_chat_server/internal/config"
	"kama_chat_server/internal/handler"
	"kama_chat_server/internal/infrastructure/logger"
	"kama_chat_server/internal/router"

	"github.com/gin-contrib/cors"
	"github.com/gin-gonic/gin"
)

// Init åˆå§‹åŒ– HTTP/HTTPS æœåŠ¡å™¨å¹¶è¿”å› Gin å¼•æ“å®ä¾‹
// handlers: é€šè¿‡ä¾èµ–æ³¨å…¥ä¼ å…¥çš„ handler èšåˆå¯¹è±¡
func Init(handlers *handler.Handlers) *gin.Engine {
	engine := gin.New()
	engine.Use(logger.GinLogger())
	engine.Use(logger.GinRecovery(true))

	// CORS é…ç½®
	corsConfig := cors.DefaultConfig()
	corsConfig.AllowOrigins = []string{"*"}
	corsConfig.AllowMethods = []string{"GET", "POST", "PUT", "DELETE", "OPTIONS"}
	corsConfig.AllowHeaders = []string{"Origin", "Content-Length", "Content-Type", "Authorization"}
	engine.Use(cors.New(corsConfig))

	// æ³¨å†Œé™æ€èµ„æºè·¯ç”±
	engine.Static("/static/avatars", config.GetConfig().StaticAvatarPath)
	engine.Static("/static/files", config.GetConfig().StaticFilePath)

	// æ³¨å†Œä¸šåŠ¡è·¯ç”±
	rt := router.NewRouter(handlers)
	rt.RegisterRoutes(engine)

	return engine
}
```

**æ¶æ„å˜åŒ–**ï¼š
- `Init` å‡½æ•°ç°åœ¨æ¥æ”¶ `*handler.Handlers` å‚æ•°å¹¶è¿”å› `*gin.Engine`
- ä¸å†ä½¿ç”¨å…¨å±€å˜é‡ `GE`
- é€šè¿‡è·¯ç”±ç®¡ç†å™¨ `router.NewRouter(handlers)` æ³¨å…¥ä¾èµ–

### 1.2 åˆ›å»ºç›®å½•

```bash
mkdir -p static/avatars
mkdir -p static/files
```

---

## 2. æ–‡ä»¶æœåŠ¡å®ç°

### 2.1 internal/service/message/service.go

> **é‡è¦ç‰¹æ€§**ï¼š
> - ä½¿ç”¨ä¾èµ–æ³¨å…¥æ¨¡å¼ï¼Œæ³¨å…¥ Repository å’Œ CacheService
> - è¿”å›æ–°ç”Ÿæˆçš„æ–‡ä»¶åä¾›å‰ç«¯ä½¿ç”¨
> - ä½¿ç”¨ Magic Bytes è¿›è¡Œ MIME ç±»å‹æ ¡éªŒ
> - ç”Ÿæˆå”¯ä¸€æ–‡ä»¶åé˜²æ­¢è¦†ç›–å’Œè·¯å¾„éå†æ”»å‡»

```go
package message

import (
	"io"
	"mime/multipart"
	"net/http"
	"os"
	"path/filepath"
	"strings"

	"github.com/gin-gonic/gin"
	"go.uber.org/zap"

	"kama_chat_server/internal/config"
	"kama_chat_server/internal/dao/mysql/repository"
	myredis "kama_chat_server/internal/dao/redis"
	"kama_chat_server/pkg/constants"
	"kama_chat_server/pkg/errorx"
	"kama_chat_server/pkg/util/random"
)

// messageService æ¶ˆæ¯ä¸šåŠ¡é€»è¾‘å®ç°
// é€šè¿‡æ„é€ å‡½æ•°æ³¨å…¥ä¾èµ–ï¼Œéµå¾ªä¾èµ–å€’ç½®åŸåˆ™
type messageService struct {
	repos *repository.Repositories
	cache myredis.AsyncCacheService
}

// NewMessageService æ„é€ å‡½æ•°ï¼Œæ³¨å…¥æ‰€æœ‰ä¾èµ–
func NewMessageService(repos *repository.Repositories, cacheService myredis.AsyncCacheService) *messageService {
	return &messageService{
		repos: repos,
		cache: cacheService,
	}
}

// UploadAvatar ä¸Šä¼ å¤´åƒï¼Œè¿”å›æ–°æ–‡ä»¶å
func (m *messageService) UploadAvatar(c *gin.Context) (string, error) {
	if err := c.Request.ParseMultipartForm(constants.FILE_MAX_SIZE); err != nil {
		zap.L().Error("parse multipart form error", zap.Error(err))
		return "", errorx.ErrServerBusy
	}
	mForm := c.Request.MultipartForm
	if len(mForm.File) == 0 {
		return "", errorx.New(errorx.CodeInvalidParam, "no file uploaded")
	}

	for _, headers := range mForm.File {
		for _, fileHeader := range headers {
			// é™åˆ¶ä¸ºå›¾ç‰‡ç±»å‹
			filename, err := m.saveFile(fileHeader, config.GetConfig().StaticAvatarPath, 
				"image/jpeg", "image/png", "image/gif")
			if err != nil {
				zap.L().Error("save avatar error", zap.Error(err))
				if errorx.GetCode(err) == errorx.CodeInvalidParam {
					continue
				}
				return "", errorx.ErrServerBusy
			}
			zap.L().Info("upload avatar success", zap.String("filename", filename))
			return filename, nil
		}
	}
	return "", errorx.New(errorx.CodeInvalidParam, "no file found")
}

// UploadFile ä¸Šä¼ æ–‡ä»¶ï¼Œè¿”å›æ–‡ä»¶ååˆ—è¡¨
func (m *messageService) UploadFile(c *gin.Context) ([]string, error) {
	if err := c.Request.ParseMultipartForm(constants.FILE_MAX_SIZE); err != nil {
		zap.L().Error("parse multipart form error", zap.Error(err))
		return nil, errorx.ErrServerBusy
	}

	var uploadedFiles []string
	dstDir := config.GetConfig().StaticFilePath
	mForm := c.Request.MultipartForm

	for _, headers := range mForm.File {
		for _, fileHeader := range headers {
			filename, err := m.saveFile(fileHeader, dstDir)
			if err != nil {
				zap.L().Error("save file error", zap.Error(err))
				// å›æ»šå·²ä¸Šä¼ çš„æ–‡ä»¶
				for _, f := range uploadedFiles {
					_ = os.Remove(filepath.Join(dstDir, f))
				}
				return nil, errorx.ErrServerBusy
			}
			zap.L().Info("upload file success", zap.String("filename", filename))
			uploadedFiles = append(uploadedFiles, filename)
		}
	}

	return uploadedFiles, nil
}

// saveFile é€šç”¨ä¿å­˜æ–‡ä»¶æ–¹æ³•ï¼Œæ”¯æŒ Magic Bytes ç±»å‹æ ¡éªŒ
func (m *messageService) saveFile(fileHeader *multipart.FileHeader, dstDir string, allowedMimes ...string) (string, error) {
	src, err := fileHeader.Open()
	if err != nil {
		return "", err
	}
	defer src.Close()

	// 1. è¯»å–å‰ 512 å­—èŠ‚è¿›è¡Œ MIME æ ¡éªŒ
	buffer := make([]byte, 512)
	if _, err := src.Read(buffer); err != nil && err != io.EOF {
		return "", err
	}
	contentType := http.DetectContentType(buffer)

	// é‡ç½®æ–‡ä»¶æŒ‡é’ˆ
	if _, err := src.Seek(0, 0); err != nil {
		return "", err
	}

	// 2. æ ¡éªŒ MIME ç±»å‹
	if len(allowedMimes) > 0 {
		isAllowed := false
		for _, mime := range allowedMimes {
			if strings.HasPrefix(contentType, mime) {
				isAllowed = true
				break
			}
		}
		if !isAllowed {
			return "", errorx.Newf(errorx.CodeInvalidParam, "invalid file type: %s", contentType)
		}
	}

	// 3. ç”Ÿæˆå”¯ä¸€æ–‡ä»¶å
	ext := strings.ToLower(filepath.Ext(fileHeader.Filename))
	newFileName := random.GetNowAndLenRandomString(10) + ext
	dst := filepath.Join(dstDir, newFileName)

	// 4. ä¿å­˜æ–‡ä»¶
	out, err := os.Create(dst)
	if err != nil {
		return "", err
	}
	defer out.Close()

	if _, err := io.Copy(out, src); err != nil {
		return "", err
	}

	return newFileName, nil
}
```

**å®‰å…¨ç‰¹æ€§**ï¼š
- **Magic Bytes æ ¡éªŒ**ï¼šè¯»å–æ–‡ä»¶å‰ 512 å­—èŠ‚æ£€æµ‹çœŸå® MIME ç±»å‹ï¼Œé˜²æ­¢æ‰©å±•åæ¬ºéª—
- **å”¯ä¸€æ–‡ä»¶å**ï¼šä½¿ç”¨æ—¶é—´æˆ³+éšæœºå­—ç¬¦ä¸²ï¼Œé˜²æ­¢è¦†ç›–å’Œè·¯å¾„éå†
- **MIME ç™½åå•**ï¼šå¤´åƒä»…å…è®¸ jpeg/png/gif ç±»å‹
- **å›æ»šæœºåˆ¶**ï¼šå¤šæ–‡ä»¶ä¸Šä¼ å¤±è´¥æ—¶åˆ é™¤å·²ä¸Šä¼ çš„æ–‡ä»¶

---

## 3. Handler å±‚

### 3.1 internal/handler/message_handler.go

```go
package handler

import (
	"kama_chat_server/internal/service"

	"github.com/gin-gonic/gin"
)

// MessageHandler æ¶ˆæ¯è¯·æ±‚å¤„ç†å™¨
// é€šè¿‡æ„é€ å‡½æ•°æ³¨å…¥ MessageService
type MessageHandler struct {
	messageSvc service.MessageService
}

// NewMessageHandler åˆ›å»ºæ¶ˆæ¯å¤„ç†å™¨å®ä¾‹
func NewMessageHandler(messageSvc service.MessageService) *MessageHandler {
	return &MessageHandler{messageSvc: messageSvc}
}

// UploadAvatar ä¸Šä¼ ç”¨æˆ·å¤´åƒ
// POST /message/uploadAvatar
func (h *MessageHandler) UploadAvatar(c *gin.Context) {
	path, err := h.messageSvc.UploadAvatar(c)
	if err != nil {
		HandleError(c, err)
		return
	}
	HandleSuccess(c, path)
}

// UploadFile ä¸Šä¼ èŠå¤©æ–‡ä»¶
// POST /message/uploadFile
func (h *MessageHandler) UploadFile(c *gin.Context) {
	paths, err := h.messageSvc.UploadFile(c)
	if err != nil {
		HandleError(c, err)
		return
	}
	HandleSuccess(c, paths)
}
```

---

## 4. è·¯ç”±é…ç½®

### 4.1 internal/router/message_routes.go

```go
package router

import (
	"github.com/gin-gonic/gin"
)

func (r *Router) RegisterMessageRoutes(group *gin.RouterGroup) {
	messageGroup := group.Group("/message")
	{
		messageGroup.GET("/getMessageList", r.handlers.Message.GetMessageList)
		messageGroup.GET("/getGroupMessageList", r.handlers.Message.GetGroupMessageList)
		messageGroup.POST("/uploadAvatar", r.handlers.Message.UploadAvatar)
		messageGroup.POST("/uploadFile", r.handlers.Message.UploadFile)
	}
}
```

---

## 5. å¸¸é‡å®šä¹‰

### 5.1 pkg/constants/constants.go

```go
package constants

const (
	CHANNEL_SIZE  = 100           // é€šé“ç¼“å†²å¤§å°
	FILE_MAX_SIZE = 30 << 20      // æ–‡ä»¶æœ€å¤§ 30 MB
	REDIS_TIMEOUT = 1             // Redis è¶…æ—¶æ—¶é—´ï¼ˆåˆ†é’Ÿï¼‰
)
```

---

## 6. å‰ç«¯ä¸Šä¼ ç¤ºä¾‹

### 6.1 JavaScript

```javascript
const formData = new FormData();
formData.append('file', fileInput.files[0]);

fetch('/message/uploadAvatar', {
    method: 'POST',
    body: formData
})
.then(response => response.json())
.then(data => {
    console.log('ä¸Šä¼ æˆåŠŸ:', data);
    // data.data å³ä¸ºæ–°å¤´åƒæ–‡ä»¶å
    avatarElement.src = '/static/avatars/' + data.data;
});
```

---

## 7. æµ‹è¯•æ–‡ä»¶ä¸Šä¼ 

### 7.1 ä½¿ç”¨ curl æµ‹è¯•

```bash
# ä¸Šä¼ å¤´åƒ
curl -X POST http://localhost:8000/message/uploadAvatar \
  -F "file=@/path/to/avatar.jpg"

# å“åº”
{
    "code": 1000,
    "msg": "success",
    "data": "20250104abc123.jpg"
}
```

### 7.2 è®¿é—®é™æ€èµ„æº

```
http://localhost:8000/static/avatars/20250104abc123.jpg
```

---

## 8. ç”Ÿäº§ç¯å¢ƒå»ºè®®

### 8.1 ä½¿ç”¨å¯¹è±¡å­˜å‚¨ (OSS/S3)

```go
import "github.com/aliyun/aliyun-oss-go-sdk/oss"

func UploadToOSS(file io.Reader, filename string) (string, error) {
	client, _ := oss.New("endpoint", "accessKeyId", "accessKeySecret")
	bucket, _ := client.Bucket("bucket-name")
	bucket.PutObject(filename, file)
	return "https://bucket.oss-cn-hangzhou.aliyuncs.com/" + filename, nil
}
```

---

## âœ… æœ¬èŠ‚å®Œæˆ

ä½ å·²ç»å®Œæˆäº†ï¼š
- [x] ä¾èµ–æ³¨å…¥æ¨¡å¼çš„æ–‡ä»¶æœåŠ¡å®ç°
- [x] Service å±‚æ–‡ä»¶ä¿å­˜ï¼ˆè¿”å›æ–‡ä»¶åï¼‰
- [x] Magic Bytes MIME ç±»å‹æ ¡éªŒ
- [x] å”¯ä¸€æ–‡ä»¶åç”Ÿæˆ
- [x] å¤šæ–‡ä»¶ä¸Šä¼ å›æ»šæœºåˆ¶
- [x] é™æ€èµ„æºè·¯ç”±é…ç½®

---

## ğŸ“š ä¸‹ä¸€æ­¥

ç»§ç»­å­¦ä¹  [21_HTTPSä¸å®‰å…¨é…ç½®.md](21_HTTPSä¸å®‰å…¨é…ç½®.md)ï¼Œä¸ºä½ çš„æœåŠ¡åŠ ä¸Šå®‰å…¨é”ã€‚
