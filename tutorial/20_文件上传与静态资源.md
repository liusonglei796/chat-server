# 20. æ–‡ä»¶ä¸Šä¼ ä¸é™æ€èµ„æº

> æœ¬æ•™ç¨‹å°†å®ç°ç”¨æˆ·å¤´åƒå’ŒèŠå¤©æ–‡ä»¶çš„ä¸Šä¼ åŠŸèƒ½ï¼Œå¹¶é…ç½®é™æ€èµ„æºæœåŠ¡ã€‚

---

## ğŸ“Œ å­¦ä¹ ç›®æ ‡

- ä½¿ç”¨ Gin å¤„ç†æ–‡ä»¶ä¸Šä¼ 
- å®‰å…¨åœ°ä¿å­˜æ–‡ä»¶ï¼ˆMIME æ ¡éªŒã€é‡å‘½åï¼‰
- é…ç½®é™æ€èµ„æºè®¿é—®
- è¿”å›æ–°ç”Ÿæˆçš„æ–‡ä»¶åä¾›å‰ç«¯ä½¿ç”¨

---

## 1. é™æ€èµ„æºé…ç½®

### 1.1 internal/https_server/https_server.go

```go
package https_server

import (
	"kama_chat_server/internal/config"
	"kama_chat_server/internal/infrastructure/logger"
	"kama_chat_server/internal/router"

	"github.com/gin-contrib/cors"
	"github.com/gin-gonic/gin"
)

var GE *gin.Engine

func Init() {
	GE = gin.New()
	GE.Use(logger.GinLogger())
	GE.Use(logger.GinRecovery(true))

	corsConfig := cors.DefaultConfig()
	corsConfig.AllowOrigins = []string{"*"}
	GE.Use(cors.New(corsConfig))

	// æ³¨å†Œé™æ€èµ„æºè·¯ç”±
	GE.Static("/static/avatars", config.GetConfig().StaticAvatarPath)
	GE.Static("/static/files", config.GetConfig().StaticFilePath)

	router.RegisterRoutes(GE)
}
```

### 1.2 åˆ›å»ºç›®å½•

```bash
mkdir -p static/avatars
mkdir -p static/files
```

---

## 2. æ–‡ä»¶æœåŠ¡å®ç°

### 2.1 internal/service/message/service.go

> **é‡è¦æ›´æ–°**ï¼š
> - è¿”å›æ–°ç”Ÿæˆçš„æ–‡ä»¶åä¾›å‰ç«¯ä½¿ç”¨
> - ä½¿ç”¨ Magic Bytes è¿›è¡Œ MIME ç±»å‹æ ¡éªŒ
> - ç”Ÿæˆå”¯ä¸€æ–‡ä»¶åé˜²æ­¢è¦†ç›–å’Œè·¯å¾„éå†æ”»å‡»

```go
package message

import (
	"io"
	"mime/multipart"
	"net/http"
	"os"
	"path/filepath"
	"strings"

	"github.com/gin-gonic/gin"
	"go.uber.org/zap"

	"kama_chat_server/internal/config"
	"kama_chat_server/internal/dao/mysql/repository"
	"kama_chat_server/pkg/constants"
	"kama_chat_server/pkg/errorx"
	"kama_chat_server/pkg/util/random"
)

type messageService struct {
	repos *repository.Repositories
}

func NewMessageService(repos *repository.Repositories) *messageService {
	return &messageService{repos: repos}
}

// UploadAvatar ä¸Šä¼ å¤´åƒï¼Œè¿”å›æ–°æ–‡ä»¶å
func (m *messageService) UploadAvatar(c *gin.Context) (string, error) {
	if err := c.Request.ParseMultipartForm(constants.FILE_MAX_SIZE); err != nil {
		zap.L().Error("parse multipart form error", zap.Error(err))
		return "", errorx.ErrServerBusy
	}
	mForm := c.Request.MultipartForm
	if len(mForm.File) == 0 {
		return "", errorx.New(errorx.CodeInvalidParam, "no file uploaded")
	}

	for _, headers := range mForm.File {
		for _, fileHeader := range headers {
			// é™åˆ¶ä¸ºå›¾ç‰‡ç±»å‹
			filename, err := m.saveFile(fileHeader, config.GetConfig().StaticAvatarPath, 
				"image/jpeg", "image/png", "image/gif")
			if err != nil {
				zap.L().Error("save avatar error", zap.Error(err))
				if errorx.GetCode(err) == errorx.CodeInvalidParam {
					continue
				}
				return "", errorx.ErrServerBusy
			}
			zap.L().Info("upload avatar success", zap.String("filename", filename))
			return filename, nil
		}
	}
	return "", errorx.New(errorx.CodeInvalidParam, "no file found")
}

// UploadFile ä¸Šä¼ æ–‡ä»¶ï¼Œè¿”å›æ–‡ä»¶ååˆ—è¡¨
func (m *messageService) UploadFile(c *gin.Context) ([]string, error) {
	if err := c.Request.ParseMultipartForm(constants.FILE_MAX_SIZE); err != nil {
		zap.L().Error("parse multipart form error", zap.Error(err))
		return nil, errorx.ErrServerBusy
	}

	var uploadedFiles []string
	dstDir := config.GetConfig().StaticFilePath
	mForm := c.Request.MultipartForm

	for _, headers := range mForm.File {
		for _, fileHeader := range headers {
			filename, err := m.saveFile(fileHeader, dstDir)
			if err != nil {
				zap.L().Error("save file error", zap.Error(err))
				// å›æ»šå·²ä¸Šä¼ çš„æ–‡ä»¶
				for _, f := range uploadedFiles {
					_ = os.Remove(filepath.Join(dstDir, f))
				}
				return nil, errorx.ErrServerBusy
			}
			zap.L().Info("upload file success", zap.String("filename", filename))
			uploadedFiles = append(uploadedFiles, filename)
		}
	}

	return uploadedFiles, nil
}

// saveFile é€šç”¨ä¿å­˜æ–‡ä»¶æ–¹æ³•ï¼Œæ”¯æŒ Magic Bytes ç±»å‹æ ¡éªŒ
func (m *messageService) saveFile(fileHeader *multipart.FileHeader, dstDir string, allowedMimes ...string) (string, error) {
	src, err := fileHeader.Open()
	if err != nil {
		return "", err
	}
	defer src.Close()

	// 1. è¯»å–å‰ 512 å­—èŠ‚è¿›è¡Œ MIME æ ¡éªŒ
	buffer := make([]byte, 512)
	if _, err := src.Read(buffer); err != nil && err != io.EOF {
		return "", err
	}
	contentType := http.DetectContentType(buffer)

	// é‡ç½®æ–‡ä»¶æŒ‡é’ˆ
	if _, err := src.Seek(0, 0); err != nil {
		return "", err
	}

	// 2. æ ¡éªŒ MIME ç±»å‹
	if len(allowedMimes) > 0 {
		isAllowed := false
		for _, mime := range allowedMimes {
			if strings.HasPrefix(contentType, mime) {
				isAllowed = true
				break
			}
		}
		if !isAllowed {
			return "", errorx.Newf(errorx.CodeInvalidParam, "invalid file type: %s", contentType)
		}
	}

	// 3. ç”Ÿæˆå”¯ä¸€æ–‡ä»¶å
	ext := strings.ToLower(filepath.Ext(fileHeader.Filename))
	newFileName := random.GetNowAndLenRandomString(10) + ext
	dst := filepath.Join(dstDir, newFileName)

	// 4. ä¿å­˜æ–‡ä»¶
	out, err := os.Create(dst)
	if err != nil {
		return "", err
	}
	defer out.Close()

	if _, err := io.Copy(out, src); err != nil {
		return "", err
	}

	return newFileName, nil
}
```

**å®‰å…¨ç‰¹æ€§**ï¼š
- **Magic Bytes æ ¡éªŒ**ï¼šè¯»å–æ–‡ä»¶å‰ 512 å­—èŠ‚æ£€æµ‹çœŸå® MIME ç±»å‹ï¼Œé˜²æ­¢æ‰©å±•åæ¬ºéª—
- **å”¯ä¸€æ–‡ä»¶å**ï¼šä½¿ç”¨æ—¶é—´æˆ³+éšæœºå­—ç¬¦ä¸²ï¼Œé˜²æ­¢è¦†ç›–å’Œè·¯å¾„éå†
- **MIME ç™½åå•**ï¼šå¤´åƒä»…å…è®¸ jpeg/png/gif ç±»å‹
- **å›æ»šæœºåˆ¶**ï¼šå¤šæ–‡ä»¶ä¸Šä¼ å¤±è´¥æ—¶åˆ é™¤å·²ä¸Šä¼ çš„æ–‡ä»¶

---

## 3. Handler å±‚

### 3.1 internal/handler/message_handler.go

```go
// UploadAvatarHandler ä¸Šä¼ å¤´åƒ
func UploadAvatarHandler(c *gin.Context) {
	filename, err := service.Svc.Message.UploadAvatar(c)
	if err != nil {
		HandleError(c, err)
		return
	}
	// è¿”å›æ–°æ–‡ä»¶å
	HandleSuccess(c, gin.H{
		"filename": filename,
		"url":      "/static/avatars/" + filename,
	})
}

// UploadFileHandler ä¸Šä¼ æ–‡ä»¶
func UploadFileHandler(c *gin.Context) {
	filenames, err := service.Svc.Message.UploadFile(c)
	if err != nil {
		HandleError(c, err)
		return
	}
	// è¿”å›æ–‡ä»¶ååˆ—è¡¨
	urls := make([]string, len(filenames))
	for i, f := range filenames {
		urls[i] = "/static/files/" + f
	}
	HandleSuccess(c, gin.H{
		"filenames": filenames,
		"urls":      urls,
	})
}
```

---

## 4. è·¯ç”±é…ç½®

### 4.1 internal/router/message_routes.go

```go
package router

import (
	"kama_chat_server/internal/handler"
	"github.com/gin-gonic/gin"
)

func RegisterMessageRoutes(r *gin.Engine) {
	messageGroup := r.Group("/message")
	{
		messageGroup.GET("/getMessageList", handler.GetMessageListHandler)
		messageGroup.GET("/getGroupMessageList", handler.GetGroupMessageListHandler)
		messageGroup.POST("/uploadAvatar", handler.UploadAvatarHandler)
		messageGroup.POST("/uploadFile", handler.UploadFileHandler)
	}
}
```

---

## 5. å¸¸é‡å®šä¹‰

### 5.1 pkg/constants/constants.go

```go
package constants

const (
	CHANNEL_SIZE  = 100           // é€šé“ç¼“å†²å¤§å°
	FILE_MAX_SIZE = 30 << 20      // æ–‡ä»¶æœ€å¤§ 30 MB
	REDIS_TIMEOUT = 1             // Redis è¶…æ—¶æ—¶é—´ï¼ˆåˆ†é’Ÿï¼‰
)
```

---

## 6. å‰ç«¯ä¸Šä¼ ç¤ºä¾‹

### 6.1 JavaScript

```javascript
const formData = new FormData();
formData.append('file', fileInput.files[0]);

fetch('/message/uploadAvatar', {
    method: 'POST',
    body: formData
})
.then(response => response.json())
.then(data => {
    console.log('ä¸Šä¼ æˆåŠŸ:', data);
    // data.data.url å³ä¸ºæ–°å¤´åƒåœ°å€
    avatarElement.src = data.data.url;
});
```

---

## 7. æµ‹è¯•æ–‡ä»¶ä¸Šä¼ 

### 7.1 ä½¿ç”¨ curl æµ‹è¯•

```bash
# ä¸Šä¼ å¤´åƒ
curl -X POST http://localhost:8000/message/uploadAvatar \
  -F "file=@/path/to/avatar.jpg"

# å“åº”
{
    "code": 1000,
    "msg": "success",
    "data": {
        "filename": "20250104abc123.jpg",
        "url": "/static/avatars/20250104abc123.jpg"
    }
}
```

### 7.2 è®¿é—®é™æ€èµ„æº

```
http://localhost:8000/static/avatars/20250104abc123.jpg
```

---

## 8. ç”Ÿäº§ç¯å¢ƒå»ºè®®

### 8.1 ä½¿ç”¨å¯¹è±¡å­˜å‚¨ (OSS/S3)

```go
import "github.com/aliyun/aliyun-oss-go-sdk/oss"

func UploadToOSS(file io.Reader, filename string) (string, error) {
	client, _ := oss.New("endpoint", "accessKeyId", "accessKeySecret")
	bucket, _ := client.Bucket("bucket-name")
	bucket.PutObject(filename, file)
	return "https://bucket.oss-cn-hangzhou.aliyuncs.com/" + filename, nil
}
```

---

## âœ… æœ¬èŠ‚å®Œæˆ

ä½ å·²ç»å®Œæˆäº†ï¼š
- [x] Service å±‚æ–‡ä»¶ä¿å­˜ï¼ˆè¿”å›æ–‡ä»¶åï¼‰
- [x] Magic Bytes MIME ç±»å‹æ ¡éªŒ
- [x] å”¯ä¸€æ–‡ä»¶åç”Ÿæˆ
- [x] å¤šæ–‡ä»¶ä¸Šä¼ å›æ»šæœºåˆ¶
- [x] é™æ€èµ„æºè·¯ç”±é…ç½®

---

## ğŸ“š ä¸‹ä¸€æ­¥

ç»§ç»­å­¦ä¹  [21_HTTPSä¸å®‰å…¨é…ç½®.md](21_HTTPSä¸å®‰å…¨é…ç½®.md)ï¼Œä¸ºä½ çš„æœåŠ¡åŠ ä¸Šå®‰å…¨é”ã€‚
