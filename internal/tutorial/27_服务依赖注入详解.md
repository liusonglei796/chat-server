# 服务层聚合与依赖注入详解

本文档深入分析 `internal/service/provider.go` 的代码实现。该文件是整个服务层（Service Layer）的 **组合根 (Composition Root)**，负责所有业务服务的初始化、依赖注入和统一管理。

## Part 1: 数据库模型与数据结构 (Database Models & Structures)

虽然 `provider.go` 本身不定义模型，但它聚合了 User, Session, Group, Contact, Message, ChatRoom 六大服务。这些服务底层操作的核心数据库模型如下：

| 模型名称 (Model) | 关键字段 (Key Fields) | 业务定义 (Business Definition) | 关联关系 (Relations) |
| :--- | :--- | :--- | :--- |
| **User** | `DeprecatedId`, `Uuid`, `Mobile`, `Nickname`, `Avatar` | **用户核心信息**。存储账号、密码（加密）、个人资料等。 | 1:1 Session (用户拥有会话列表)<br>1:N UserContact (用户有多个好友) |
| **Session** | `Uuid`, `SendId` (Owner), `ReceiveId` (Target), `LastMessage` | **会话索引**。记录“我的消息列表/群聊列表”，用于快速展示聊天入口。 | N:1 User (属于某个用户)<br>N:1 User/Group (指向目标) |
| **GroupInfo** | `Uuid`, `Name`, `OwnerId`, `Avatar` | **群组基本信息**。存储群名称、公告、群主等元数据。 | 1:N GroupMember (群里有多个成员) |
| **GroupMember** | `GroupUuid`, `UserUuid`, `Role`, `MuteEndTime` | **群成员关系**。记录用户在群内的角色（群主/管理员/成员）及状态（禁言）。 | N:1 GroupInfo<br>N:1 User |
| **UserContact** | `OwnerId`, `ContactId`, `Remark` | **用户好友关系**。记录“我添加了谁”以及备注名。 | N:1 User (Owner)<br>N:1 User (Contact) |
| **ContactApply** | `UserId`, `FriendId`, `Status`, `Remark` | **好友申请单**。记录申请添加好友的历史状态（待通过/已拒绝）。 | N:1 User (Requester)<br>N:1 User (Target) |
| **Message** | `Uuid`, `SessionId`, `Content`, `Type`, `Url` | **消息实体**。存储每一条聊天记录（文本、图片、文件）。 | N:1 Session (属于某个会话)<br>N:1 User (发送者) |

---

## Part 2: 函数级深度解析 (Function Analysis)

`provider.go` 中的代码量很少，但作用关键。

| 函数名 | 核心目的 (Core Purpose) | 应用场景 (Application Scenario) | 逻辑过程 (Logical Process) |
| :--- | :--- | :--- | :--- |
| `NewServices` | **工厂方法**：创建并组装所有 Service 实例。 | 系统启动时，在 `main.go` 或依赖注入层调用。 | 1. **接收依赖**：传入 `repository.Repositories` 指针（统一的数据访问层）。<br>2. **逐个初始化**：以此调用各模块的 `NewXxxService(repos)`：<br>&nbsp;&nbsp;- `session.NewSessionService`<br>&nbsp;&nbsp;- `user.NewUserService`<br>&nbsp;&nbsp;- `group.NewGroupService`<br>&nbsp;&nbsp; ... (共6个)<br>3. **聚合返回**：将创建好的实例填充到 `&Services{}` 结构体中并返回。 |
| `InitServices` | **全局初始化**：设置单例变量 `Svc`。 | 遗留代码或为了方便非 Controller 层直接调用 Service。 | 1. **调用工厂**：执行 `NewServices(repos)`。<br>2. **赋值单例**：将结果赋值给全局变量 `Svc`。<br>*注：建议尽量减少对全局变量 `Svc` 的直接依赖，优先使用依赖注入。* |

---

## Part 3: 实现核心与全局思维 (The Essence of Implementation)

如果您要重构或从零实现这部分代码，必须掌握以下三个核心维度：

### 1. 数据流转核心 (Data Flow Core)
整个后端的 **“Handler -> Service -> DAO”** 三层架构在这里完成了 **Service -> DAO** 的绑定：
*   **输入**: `*repository.Repositories`。这是所有 DAO（GORM DB Wrapper）的集合。
*   **输出**: `*Services`。这是所有业务逻辑的集合。
*   **流转**:
    ```text
    [Main/Wire] 
       ↓ 初始化 Repositories (DB Connection)
       ↓ 
    [provider.InitServices] 
       ↓ 注入 Repositories
    [Service Instances] 
       UserSvc { repos }
       GroupSvc { repos }
       ...
    ```
    所有 Service 共享**同一个** `repos` 实例。这意味着它们共享同一个数据库连接池配置，这对于实现跨 Service 的事务（虽然目前代码未体现跨 Service 事务，但架构上支持）至关重要。

### 2. 关键约束 (Key Constraints)
*   **结构解耦 (Structural Decoupling)**:
    注意 `NewServices` 中，每个 Service 的构造函数**仅**接收 `repos`，而不接收其他 Service 实例。
    *   **优点**: 彻底避免了 **循环依赖 (Circular Dependency)** 问题（例如：User 需要 Group，Group 又需要 User）。
    *   **隐含规则**: 这意味着 Service 之间无法直接互相调用（Model 层面的关联除外）。如果业务确实需要 Service A 调用 Service B，当前架构需要重构（如引入 EventBus 或上层 Facade），或者只能在 Handler 层协调。
*   **依赖倒置 (Dependency Inversion)**:
    虽然代码直接依赖了具体实现（`kama_chat_server/internal/service/xxx`），但通过 `repos` 的注入，数据层已经实现了倒置。如果未来要换数据库实现，只需替换 `repos` 即可，Service 层逻辑无需大改。

### 3. 技术难点 (Technical Difficulties)
*   **初始化顺序 (Initialization Order)**:
    当前看起来各 Service 是独立的。但如果未来某个 Service 在初始化时需要加载配置或做预热（如 ChatRoomService 启动时预加载 Redis），则 `NewServices` 中的实例化顺序就会变得敏感。
*   **并发安全性 (Concurrency)**:
    `Svc` 是全局变量。在 `InitServices` 被调用后，它是**只读**的（字段不再改变）。因此，只要初始化过程是串行的（在 `main` 中），后续并发读取 `Svc` 是安全的。但如果有人试图在运行时修改 `Svc` 的字段，将会引发严重的 Race Condition。
