# 消息服务 (Message Service) 功能详解

本文档深度解析 `internal/service/message/service.go` 的架构逻辑与实现细节。该服务是聊天系统的核心业务层，主要负责消息历史记录的检索（单聊/群聊）以及文件/头像的上传处理。

## 1. 核心架构概述

**文件路径**: `internal/service/message/service.go`

**定位**: 连接 HTTP/WebSocket 接口层与数据持久层（MySQL/Redis/文件系统）。

### 核心职责
1.  **消息查询**: 提供单聊和群聊的历史消息获取接口，支持缓存加速。
2.  **资源上传**: 处理头像和普通文件的上传，包含安全校验和存储逻辑。

---

## 2. 函数级深度解析

下表对文件中的核心函数进行了逻辑拆解，帮助开发者快速理解每个方法的执行流程。

| 函数名 | 核心目的 (Core Purpose) | 应用场景 (Application Scenario) | 逻辑过程 (Logical Process) |
| :--- | :--- | :--- | :--- |
| `NewMessageService` | 初始化消息服务实例，注入依赖。 | 在服务器启动或依赖注入容器初始化时调用。 | 1. 接收 `repository.Repositories` 指针（数据库访问层封装）。<br>2. 返回包含该依赖的 `messageService` 实例指针。 |
| `GetMessageList` | 获取两个用户之间的历史聊天记录（单聊）。 | 用户打开与好友的聊天窗口时，需要加载历史消息。 | 1. **ID 排序**：将 `userOneId` 和 `userTwoId` 排序，确保 A查B 和 B查A 生成的缓存 Key 一致。<br>2. **查询缓存**：构建 Redis Key，尝试获取缓存数据。<br>3. **缓存命中**：若存在且解析成功，直接返回数据。<br>4. **查询数据库**：若缓存未命中，调用 `m.repos.Message.FindByUserIds` 从 MySQL 获取。<br>5. **格式化响应**：将数据库实体转换为前端友好的 DTO 格式。<br>6. **异步回填缓存**：启动 Goroutine 将结果序列化并写入 Redis（设置过期时间）。<br>7. **返回结果**。 |
| `GetGroupMessageList` | 获取指定群组的历史消息记录。 | 用户进入群聊界面时，加载群聊历史。 | 1. **查询缓存**：根据 `groupId` 构建 Key，尝试从 Redis 检索。<br>2. **缓存处理**：命中缓存则解析返回；未命中或错误记录日志但继续流程。<br>3. **查询数据库**：调用 `m.repos.Message.FindByGroupId` 从 MySQL 获取群消息。<br>4. **格式化响应**：遍历结果集，映射为 `GetGroupMessageListRespond` 结构。<br>5. **异步回填缓存**：启动 Goroutine 更新 Redis 缓存。<br>6. **返回结果**。 |
| `UploadAvatar` | 处理用户头像上传请求，保证安全性。 | 用户在个人中心修改头像。 | 1. **解析表单**：解析 HTTP Multipart 表单（限制大小）。<br>2. **验证文件**：检查是否有文件上传。<br>3. **保存处理**：遍历文件（通常取第一个），调用内部方法 `saveFile`。<br>4. **安全校验**：`saveFile` 中强制校验 MIME 类型必须为图片（jpeg/png/gif）。<br>5. **结果返回**：成功则返回文件名，校验失败则根据错误类型决定是否跳过或返回错误。 |
| `UploadFile` | 处理通用文件上传请求（支持批量）。 | 用户在聊天中发送图片、视频或文档。 | 1. **初始化环境**：解析表单，确定目标存储目录。<br>2. **批量处理**：遍历所有上传的文件。<br>3. **逐个保存**：调用 `saveFile` 保存文件（此处未限制 MIME 类型）。<br>4. **原子性回滚**：如果某个文件保存失败，通过 `os.Remove` 删除本次请求中已成功保存的所有文件，确保“全成功或全失败”。<br>5. **返回结果**：返回所有成功保存的文件名列表。 |
| `saveFile` (Internal) | 通用的文件安全保存逻辑，包含 Magic Bytes 校验。 | 被 `UploadAvatar` 和 `UploadFile` 内部调用。 | 1. **读取头部**：打开文件，读取前 512 字节。<br>2. **类型检测**：使用 `http.DetectContentType` 基于文件内容（Magic Bytes）检测真实 MIME 类型。<br>3. **权限校验**：如果传入了允许的 `allowedMimes`，则对比检测到的类型，不匹配直接报错。<br>4. **生成文件名**：生成 10 位随机字符串 + 原始扩展名，防止文件名冲突和路径遍历。<br>5. **写入磁盘**：创建文件并流式写入内容 (`io.Copy`)。<br>6. **返回文件名**。 |

---

## 3. 核心数据模型 (Core Data Models)

消息服务围绕着核心实体 `Message` 展开，同时通过专门的 DTO（Data Transfer Object）将其转化为前端可用的格式。

### 3.1 数据库实体 (Database Entity)

**源文件**: `internal/model/message.go`
**表名**: `message`

这是持久化存储在 MySQL 中的数据结构，包含了消息的所有元数据和状态。

| 字段名 | 类型 | 说明 | 关键实现细节 |
| :--- | :--- | :--- | :--- |
| `ID` | `uint` | 主键 ID | GORM 默认主键，自增。 |
| `Uuid` | `string` | 消息唯一标识 | 使用 `char(20)` 存储，作为业务层面的唯一 ID，用于去重和引用。 |
| `SessionId` | `string` | 会话 ID | **核心字段**。用于标识这条消息属于哪个会话（单聊或群聊）。查询历史记录时依赖此索引。 |
| `SendId` / `ReceiveId` | `string` | 发送/接收者 ID | 关联用户表的 `uuid`。建立消息与用户的归属关系。 |
| `Type` | `int8` | 消息类型 | 枚举值控制逻辑：<br>• `0`: 文本 (Text)<br>• `1`: 语音 (Voice)<br>• `2`: 文件 (File)<br>• `3`: 通话 (Call) |
| `Content` | `string` | 文本内容 | 使用 `TEXT` 类型存储长文本。对于非文本消息，此字段可能存储描述或为空。 |
| `Url` | `string` | 资源链接 | 用于图片、语音、文件消息，存储指向静态资源的 URL 路径。 |
| `FileType`/`Name`/`Size` | `string` | 文件元数据 | 冗余存储文件的类型后缀、原始文件名和大小，避免每次展示都需要去文件系统查。 |
| `Status` | `int8` | 发送状态 | `0`: 未发送, `1`: 已发送。可用于实现消息重发机制或“对方正在输入”等状态的扩展。 |

### 3.2 响应数据传输对象 (Response DTO)

**源文件**: `internal/dto/respond/get_message_list_respond.go`

这是接口层（API）最终返回给前端 JSON 数据结构。它是 `model.Message` 的一个子集和格式化版本。

```go
type GetMessageListRespond struct {
    SendId     string `json:"send_id"`     // 发送者 ID
    SendName   string `json:"send_name"`   // 发送者昵称 (冗余字段，方便前端直接展示)
    SendAvatar string `json:"send_avatar"` // 发送者头像 (冗余字段，方便前端直接展示)
    ReceiveId  string `json:"receive_id"`  // 接收者 ID
    Type       int8   `json:"type"`        // 消息类型
    Content    string `json:"content"`     // 文本内容
    Url        string `json:"url"`         // 媒体资源链接
    FileType   string `json:"file_type"`   // 文件类型 (如 "jpg", "doc")
    FileName   string `json:"file_name"`   // 原始文件名
    FileSize   string `json:"file_size"`   // 文件大小
    CreatedAt  string `json:"created_at"`  // 时间格式化： "2006-01-02 15:04:05"
}
```

**设计洞察**:
1.  **数据扁平化 (Flattening)**: DTO 直接包含了发送者的 `Name` 和 `Avatar`。在数据库层面，这些通常存在于 `user` 表中。我们采用了“读时混入”或直接存储快照（取决于具体实现，KamaChat 中通常是在消息持久化时就记入了发送者信息，或者是 Join 查询），这样前端拿到列表就能直接渲染，无需再次请求用户详情。
2.  **时间格式化**: 数据库存的是 `time.Time` 对象，但 DTO 转成了 `string`，确保前后端时间格式展示统一。

---

## 4. 全局实现核心 (The Core of Implementation)

如果您要从零复刻此服务，以下是必须掌握的四大核心架构要素：

### 4.1 关键依赖与环境 (Dependencies & Environment)
*   **依赖注入 (DI)**: 代码严重依赖 `repository.Repositories`。这意味着你不能直接在 Service 初始化数据库连接，而必须先构建好 DAO 层，通过 `NewMessageService` 注入。与数据访问解耦。
*   **Web 框架**: 深度绑定 `Gin` 框架（`*gin.Context`），用于处理文件上传的 Multipart 表单。
*   **存储设施**:
    *   **Redis**: 硬性依赖，用于“缓存旁路”模式（Cache-Aside）。
    *   **文件系统**: 依赖本地磁盘存储上传的文件。须确保配置路径（`config.GetConfig().StaticAvatarPath`）存在且有**读写权限**。

### 4.2 数据流与状态管理 (Data Flow & State Management)
*   **缓存优先读 (Read-Through-Like / Cache-Aside)**:
    *   **数据流向**: 请求 -> Redis -> (Miss) -> MySQL -> Redis (Set) -> 返回。
    *   **设计亮点**: 使用了 **异步回填 (Async Cache Update)**，即 `go func() { ... SetKeyEx ... }()`。不在关键路径上阻塞，提升响应速度。
*   **无状态设计**: Service 本身是无状态的（Stateless），易于水平扩展。
*   **文件流转**: `HTTP Request Body` -> `Memory/Temp` -> `Disk`。利用 `io.Copy` 进行流式传输。

### 4.3 核心算法或设计模式 (Core Algorithms & Patterns)
*   **缓存键生成策略 (Sort-First Key Generation)**:
    在 `GetMessageList` 中，使用了 `if userOneId > userTwoId { swap }`。
    ```go
    // 经典算法：保证 A-B 和 B-A 生成相同的 Key，复用缓存
    cacheKey := "message_list_" + min(id1, id2) + "_" + max(id1, id2)
    ```
*   **魔数校验 (Magic Bytes Validation)**:
    在 `saveFile` 中，不信任用户上传的 `Content-Type` 头，而是通过读取文件头 512 字节 (`src.Read(buffer)`) 并使用 `http.DetectContentType` 来判断真实文件类型。这是防止伪装文件攻击（如将 `.exe` 改名为 `.jpg` 上传）的关键。
*   **事务性回滚 (Manual Transaction Rollback)**:
    在 `UploadFile` 批量上传中，手动实现了简单的事务机制：一旦任何一个文件保存失败，立即遍历回滚删除已保存的文件。

### 4.4 潜在陷阱 (Potential Pitfalls)
*   **Goroutine 竞态与 Context**:
    缓存回填使用了 `go func()`。需注意不要在异步 Goroutine 中使用 `*gin.Context`，因为请求结束时 Context 会被 Cancel 或回收。本代码中使用的是值拷贝或独立的变量，是安全的。
*   **文件扩展名信任**::
    代码优先使用了 `http.DetectContentType` 进行校验，但生成文件名时使用了原始文件名后缀 `filepath.Ext(fileHeader.Filename)`。虽然有随机名防止覆盖，但建议建立**Strict Whitelist**（如 `.jpg`, `.png`）来映射后缀，而非直接使用用户提供的后缀。
*   **Redis 穿透/雪崩**:
    当前代码在 Redis 错误时只记录日志并回退到 DB。在高并发场景下，如果 Redis 挂掉，需要一种保护机制（如 SingleFlight）来防止 DB 被瞬间打垮。
