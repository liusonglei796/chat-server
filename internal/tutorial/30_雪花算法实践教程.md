# 雪花算法 (Snowflake ID) 实践教程

本教程记录了如何将 `Message` 表的主键从随机字符串迁移到 **Snowflake 雪花算法** 生成的 `int64` ID，以提升数据库写入性能和查询效率。

## 1. 为什么选择 Snowflake？

### 1.1 原方案问题

原先使用 `"M" + random.GetNowAndLenRandomString(11)` 生成消息 ID：
```go
Uuid: fmt.Sprintf("M%s", random.GetNowAndLenRandomString(11))
// 结果示例: M240103aBcD1234567
```

**问题**：
- **索引效率低**：字符串索引占用空间大（20 字节 vs 8 字节）
- **写入性能差**：无序字符串导致 B+ 树频繁页分裂
- **排序依赖 created_at**：无法直接用 ID 排序

### 1.2 Snowflake 优势

| 维度 | 随机字符串 | Snowflake |
|:-----|:----------|:----------|
| 数据类型 | `char(20)` | `bigint` |
| 索引大小 | 20 字节 | 8 字节 |
| 有序性 | 无序 | 时间有序 |
| 写入模式 | 随机插入 | 追加写入 |

---

## 2. 实现步骤

### 2.1 安装依赖

```bash
go get github.com/bwmarrin/snowflake
```

### 2.2 创建 Snowflake 生成器

**文件**: `pkg/util/snowflake/snowflake.go`

```go
package snowflake

import (
    "sync"
    "github.com/bwmarrin/snowflake"
    "go.uber.org/zap"
    "kama_chat_server/internal/config"
)

var (
    node     *snowflake.Node
    nodeOnce sync.Once
)

// Init 初始化雪花节点 (程序启动时调用一次)
func Init() {
    nodeOnce.Do(func() {
        machineID := config.GetConfig().SnowflakeConfig.MachineID
        if machineID < 0 || machineID > 1023 {
            machineID = 1
        }
        var err error
        node, err = snowflake.NewNode(machineID)
        if err != nil {
            zap.L().Fatal("Failed to initialize snowflake node", zap.Error(err))
        }
    })
}

// GenerateID 生成雪花 ID (int64)
func GenerateID() int64 {
    if node == nil {
        Init()
    }
    return node.Generate().Int64()
}
```

**要点**：
- 使用 `sync.Once` 确保单例初始化
- `MachineID` 范围 0-1023，分布式部署时每个节点需不同

### 2.3 添加配置

**文件**: `configs/config.toml`
```toml
[snowflakeConfig]
machineId = 1  # 节点 ID (0-1023)
```

**文件**: `internal/config/config.go`
```go
type SnowflakeConfig struct {
    MachineID int64 `toml:"machineId"`
}

type Config struct {
    // ...
    SnowflakeConfig `toml:"snowflakeConfig"`
}
```

### 2.4 修改 Message 模型

**文件**: `internal/model/message.go`

```diff
type Message struct {
    ID        uint  `gorm:"primaryKey"`
    CreatedAt time.Time
-   Uuid      string `gorm:"column:uuid;uniqueIndex;type:char(20);not null"`
+   Uuid      int64  `gorm:"column:uuid;uniqueIndex;type:bigint;not null"`
    // ...
}
```

### 2.5 更新消息创建代码

在所有创建 `Message` 的地方替换：

```diff
message := model.Message{
-   Uuid: fmt.Sprintf("M%s", random.GetNowAndLenRandomString(11)),
+   Uuid: snowflake.GenerateID(),
    // ...
}
```

**涉及文件**：
- `internal/gateway/websocket/channel_server.go` (3 处)
- `internal/infrastructure/mq/kafka_consumer.go` (3 处)

### 2.6 同步修改相关类型

由于 `Message.Uuid` 从 `string` 变为 `int64`，需要同步修改：

1. **MessageBack 结构体**
   ```go
   // internal/gateway/websocket/conn_manager.go
   type MessageBack struct {
       Message []byte
       Uuid    int64  // 从 string 改为 int64
   }
   ```

2. **MessageSender 接口**
   ```go
   // internal/infrastructure/mq/interface.go
   type MessageSender interface {
       SendMessage(userId string, message []byte, uuid int64) error // 参数类型变更
       // ...
   }
   ```

---

## 3. 数据库迁移

### 3.1 自动迁移 (推荐)

如果使用 GORM AutoMigrate（本项目已使用），重启服务即可自动变更列类型。

### 3.2 手动迁移

```sql
ALTER TABLE message MODIFY COLUMN uuid BIGINT NOT NULL;
```

---

## 4. JavaScript 精度问题

Snowflake ID 是 64 位整数，而 JavaScript 的 `Number` 类型只能安全表示 53 位整数。

**当前状态**：本项目的前端 DTO (`GetMessageListRespond`) 不包含 `uuid` 字段，因此**无精度丢失风险**。

**如需暴露给前端**：将 ID 转为字符串传输：
```go
type MessageDTO struct {
    Uuid string `json:"uuid"` // 使用 string
}

// 构造时转换
dto := MessageDTO{
    Uuid: strconv.FormatInt(message.Uuid, 10),
}
```

---

## 5. 验证

```bash
# 编译检查
go build ./...

# 启动服务后发送消息，查看数据库
SELECT uuid FROM message ORDER BY id DESC LIMIT 5;
# 结果应为类似: 1874382749382749184
```

---

## 6. 总结

| 变更项 | 修改内容 |
|:-------|:---------|
| 新增文件 | `pkg/util/snowflake/snowflake.go` |
| 配置 | `config.toml` + `config.go` 新增 `SnowflakeConfig` |
| 模型 | `Message.Uuid` 类型 `string` → `int64` |
| 接口 | `MessageSender.SendMessage` 参数类型变更 |
| 业务代码 | 6 处消息创建逻辑更新 |
