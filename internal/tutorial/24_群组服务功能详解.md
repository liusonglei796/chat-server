# Group Service 功能详解文档

本文档详细说明了 `internal/service/group/service.go` 中各个核心方法的设计目的、应用场景及内部逻辑。

## 1. CreateGroup
**函数签名**: `CreateGroup(groupReq request.CreateGroupRequest) error`

*   **核心目的**: 创建一个新的群聊。
*   **应用场景**: 
    *   用户在 App 首页点击右上角 + 号，选择“发起群聊”。
    *   用户选择一批好友，点击“完成”创建。
*   **逻辑过程**:
    1.  **开启事务**: 确保创建群和添加群主成员的原子性。
    2.  **创建群记录**: 插入 `group_info` 表，生成 Group UUID。
    3.  **创建群主记录**: 插入 `group_member` 表，将发起人设为群主 (`Role=2` 或 `Role=3`，视枚举定义)。
        *   同时创建 `Contact` (User->Group) 关系。
    4.  **提交事务**。
    5.  **异步缓存**:
        *   缓存群信息 `group_info_<gid>`。
        *   更新群主的“加入群聊列表”缓存。

## 2. LoadMyGroup
**函数签名**: `LoadMyGroup(userId string) ([]respond.LoadMyGroupRespond, error)`

*   **核心目的**: 获取由“我”创建的群聊列表。
*   **应用场景**: 
    *   通讯录 -> 群组 -> “我创建的群”。
*   **逻辑过程**:
    1.  **查询缓存**: 尝试从 Redis (`my_created_group_list_<uid>`) 获取。
    2.  **缓存回源**: 查询 `group_info` 表，条件 `owner_id = userId`。
    3.  **数据返回**: 返回群 ID、名称、头像等简要信息。
    4.  **回写缓存**。

## 3. CheckGroupAddMode
**函数签名**: `CheckGroupAddMode(groupId string) (int8, error)`

*   **核心目的**: 检查群的加群方式（直接进群/需要验证/禁止加入）。
*   **应用场景**: 
    *   用户扫描群二维码时。
    *   搜索群 ID 准备申请加群时。
*   **逻辑过程**:
    *   优先查 Redis 群详情缓存。
    *   若无，查数据库获取 `AddMode` 字段。
    *   返回枚举值 (0: 无需验证, 1: 需要验证, 2: 禁止加入 等)。

## 4. EnterGroupDirectly
**函数签名**: `EnterGroupDirectly(groupId, userId string) error`

*   **核心目的**: 用户跳过验证直接加入群聊。
*   **应用场景**: 
    *   扫码进群（如果群开启了“扫码直接进群”）。
    *   被好友邀请进群（如果不需要群主确认）。
*   **逻辑过程**:
    1.  **开启事务**。
    2.  **创建成员记录**: 插入 `GroupMember`，角色为普通成员。
    3.  **创建联系人记录**: 插入 `Contact` (User->Group)。
    4.  **更新群人数**: `MemberCount + 1`。
    5.  **提交事务**。
    6.  **清理缓存**: 清理群成员列表、群信息、用户加入列表缓存。

## 5. LeaveGroup
**函数签名**: `LeaveGroup(userId string, groupId string) error`

*   **核心目的**: 普通成员退出群聊。
*   **应用场景**: 
    *   群设置页 -> “退出群聊”。
*   **逻辑过程**:
    1.  **权限检查**: 确保不是群主（群主只能解散，不能退群，或者需先转让）。
    2.  **开启事务**。
    3.  **删除成员记录**: 软删除 `GroupMember`。
    4.  **删除联系人记录**: 软删除 `Contact`。
    5.  **减少群人数**: `MemberCount - 1`。
    6.  **提交事务**。
    7.  **清理缓存**。

## 6. DismissGroup
**函数签名**: `DismissGroup(ownerId, groupId string) error`

*   **核心目的**: 群主解散群聊。
*   **应用场景**: 
    *   群管理页 -> “解散该群”。
*   **逻辑过程**:
    1.  **权限校验**: 确认操作者是群主 (`OwnerId` 匹配)。
    2.  **开启事务**。
    3.  **标记删除**: 软删除 `GroupInfo`。
    4.  **清理成员**: 软删除该群所有 `GroupMember` 记录（或者依靠逻辑删除群后成员关联失效）。
    5.  **提交事务**。
    6.  **清理缓存**: 清理大量相关缓存（所有成员的群列表缓存可能需要清理，或等待过期）。
    7.  **异步通知**: (可选) 给所有成员发系统通知“群已被解散”。

## 7. GetGroupInfo
**函数签名**: `GetGroupInfo(groupId string) (*respond.GetGroupInfoRespond, error)`

*   **核心目的**: 获取群详细资料。
*   **应用场景**: 
    *   群聊天界面的顶部标题栏。
    *   群设置页面。
*   **逻辑过程**:
    *   **Cache-Aside**: 查 `group_info_<gid>` -> 查 MySQL -> 写回 Redis。
    *   返回全量详情：头像、公告、人数、群主ID、加群模式等。

## 8. GetGroupInfoList (Admin)
**函数签名**: `GetGroupInfoList(req request.GetGroupListRequest) (*respond.GetGroupListWrapper, error)`

*   **核心目的**: 后台管理系统分页查询群列表。
*   **应用场景**: 
    *   运营后台 -> 群组管理。
*   **逻辑过程**:
    *   直接查询数据库，支持分页 (`Offset`, `Limit`)。
    *   返回群列表及总数 (`Count`)。

## 9. DeleteGroups (Admin)
**函数签名**: `DeleteGroups(uuidList []string) error`

*   **核心目的**: 管理员强制解散/封禁群。
*   **应用场景**: 
    *   后台管理 -> 违规群处理 -> 批量删除。
*   **逻辑过程**:
    *   批量软删除 `GroupInfo` 表记录。

## 10. SetGroupsStatus (Admin)
**函数签名**: `SetGroupsStatus(uuidList []string, status int8) error`

*   **核心目的**: 管理员封禁/解封群。
*   **应用场景**: 
    *   后台管理 -> 封禁违规群（群还在，但不可发言/不可加入）。
*   **逻辑过程**:
    *   更新 `status` 字段 (1: 正常, 2: 禁用)。
    *   清理相关群的 Redis 缓存，强制下一次读取最新状态。

## 11. UpdateGroupInfo
**函数签名**: `UpdateGroupInfo(req request.UpdateGroupInfoRequest) error`

*   **核心目的**: 修改群资料。
*   **应用场景**: 
    *   群主/管理员修改群名、群公告、群头像。
*   **逻辑过程**:
    1.  **字段检测**: 检查哪些字段不为空，动态构建 Update SQL。
    2.  **执行更新**: MySQL Update。
    3.  **删除缓存**: `DelKey("group_info_" + gid)`。

## 12. GetGroupMemberList
**函数签名**: `GetGroupMemberList(groupId string) ([]respond.GetGroupMemberListRespond, error)`

*   **核心目的**: 获取群成员列表（用于 UI 展示）。
*   **应用场景**: 
    *   群设置 -> 查看“群成员”。
    *   展示群成员头像九宫格。
*   **逻辑过程**:
    1.  **查询缓存**: `group_memberlist_<gid>`。
    2.  **缓存回源**: 
        *   查询 `GroupMember` 表获取 UserUUIDs。
        *   批量查询 `User` 表获取昵称、头像。
    3.  **组装数据**: 合并 UserInfo 和 GroupMemberRole（区分群主/管理员/成员）。
    4.  **回写缓存**。
    *   **注意**: 这是一个“重”接口，返回包含头像昵称的完整列表。仅用于 UI 展示。消息推送应使用 `chatroom` 服务的轻量级 ID 列表。

## 13. RemoveGroupMembers
**函数签名**: `RemoveGroupMembers(req request.RemoveGroupMembersRequest) error`

*   **核心目的**: 踢人。
*   **应用场景**: 
    *   群主/管理员移除违规成员。
*   **逻辑过程**:
    1.  **开启事务**。
    2.  **循环处理**: 遍历被踢的 ID 列表。
        *   软删除 `GroupMember`。
        *   软删除 `Contact`。
        *   群人数递减。
    3.  **提交事务**。
    4.  **清理缓存**: 清理群信息（人数变了）、成员列表、被踢人的“加入群列表”。

## 14. 核心实现要点总结 (Core Implementation Concepts)
要想实现上述所有代码，核心在于**维护“数据一致性”和“高并发读取”之间的平衡**。

最核心的要点可以总结为 **“一角三角，两套缓存，三层防线”**：

### 1. 一个三角关系 (数据模型核心)
在群组业务中，所有的写操作（建群、加人、退群）都必须同时维护三张表的“三角平衡”，**缺一不可**。这三者必须在**同一个事务 (Transaction)** 中完成：
*   **GroupInfo 表**: 群本身的实体（群名、公告）。
*   **GroupMember 表**: 成员关系（你是群主还是成员）。
*   **Contact 表**: 用户视图（这个群在不在你的通讯录列表里）。
    *   *核心难点*: 如果你删了 Member 表但没删 Contact 表，用户会看到一个点不进去的“幽灵群”；反之，群存在但列表里没有。

### 2. 两套缓存策略 (性能核心)
群组服务是高频读取场景（每次打开 App 都要加载），必须依赖 Redis，主要分为两类 Key：
*   **实体缓存 (`group_info_<gid>`)**:
    *   存的是群的详情（头像、名字）。
    *   *策略*: **Cache-Aside**。读：先查 Redis -> 没命中查 DB -> 回写 Redis。写/更新：**直接删除** Redis Key，强迫下次读取回源。
*   **关系缓存 (`group_memberlist_<gid>`, `my_joined_group_list_<uid>`)**:
    *   存的是“ID 列表”。
    *   *策略*: 任何成员变动（进群、退群、踢人），都必须**同时清理**“群的成员列表”缓存和“人的群列表”缓存。

### 3. 三层防线 (健壮性核心)
*   **第一层：权限与状态校验**
    *   任何操作前先查状态：群还在吗？被封禁了吗 (`Status==DISABLE`)？你是群主吗（才有权踢人/解散）？
*   **第二层：数据库事务**
    *   `repos.Transaction(func(tx) error { ... })` 是标配。写操作不加事务 = 必出 Bug。
*   **第三层：异步收尾**
    *   缓存的删除、系统通知的发送，通常放在事务提交成功后的 `go func()` 中异步执行。即使异步清理缓存失败，大不了短暂的数据不一致（TTL过期后自动修复），但不能阻塞主业务流程。

