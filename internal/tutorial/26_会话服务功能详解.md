# 会话服务 (Session Service) 功能详解

本文档深度解析 `internal/service/session/service.go` 的架构逻辑与实现细节。该服务负责管理用户与用户、用户与群组之间的聊天会话列表。

## 1. 核心架构概述

**文件路径**: `internal/service/session/service.go`

**定位**: 维护用户的“最近联系人”列表，管理会话的创建、查询与删除。它是消息系统的入口索引。

### 核心职责
1.  **会话管理**: 创建新会话（单聊/群聊）、删除会话。
2.  **权限校验**: 在发起会话前检查对方状态（是否被禁用、是否被拉黑）。
3.  **列表获取**: 高效获取用户的单聊和群聊会话列表，支持缓存。

---

## 2. 函数级深度解析

下表对文件中的核心函数进行了逻辑拆解。

| 函数名 | 核心目的 (Core Purpose) | 应用场景 (Application Scenario) | 逻辑过程 (Logical Process) |
| :--- | :--- | :--- | :--- |
| `NewSessionService` | 初始化服务实例。 | 系统启动时依赖注入。 | 1. 注入 `repository.Repositories`。<br>2. 返回服务实例。 |
| `CreateSession` | 创建一个新的会话记录（如果不存在）。 | 用户首次向某人/某群发消息，或搜索并点击进入聊天时。 | 1. **幂等检查**：先查库，若会话已存在直接返回 Uuid。<br>2. **发送方校验**：确认发起人存在。<br>3. **接收方校验**：根据 ID 前缀判断是用户('U')还是群组('G')，校验是否存在及状态是否正常。<br>4. **构建实体**：生成会话 UUID，填充名称头像等快照信息。<br>5. **写入数据库**：持久化存储。<br>6. **清理缓存**：异步删除发送者的会话列表缓存，强制下次拉取最新数据。<br>7. **返回结果**。 |
| `CheckOpenSessionAllowed` | 预检查是否允许发起会话。 | 点击“发送消息”或进入聊天页面前的鉴权。 | 1. **拉黑校验**：查 `Contact` 表，若一方拉黑另一方，直接拒绝。<br>2. **状态校验**：调用 `checkTargetStatusWithCache` 检查目标是否被禁用。 |
| `OpenSession` | 打开指定用户的会话（类似 Get or Create）。 | 点击联系人卡片进入聊天时。 | 1. **查缓存**：根据双向 ID 查询 Redis 缓存的会话信息。<br>2. **查数据库**：缓存未命中则查库。<br>3. **自动创建**：若数据库也未找到，自动调用 `CreateSession` 创建新会话。<br>4. **回写缓存**：将查询或创建的结果写入 Redis。 |
| `GetUserSessionList` | 获取用户的单聊会话列表。 | 客户端“消息” Tab 页展示。 | 1. **查缓存**：读取 `direct_session_list_` Key。<br>2. **查数据库**：缓存未命中则查库。<br>3. **过滤数据**：遍历结果，只保留 `ReceiveId` 以 'U' 开头的记录。<br>4. **回写缓存**：异步更新 Redis。<br>5. **返回列表**。 |
| `GetGroupSessionList` | 获取用户的群聊会话列表。 | 客户端“群组” Tab 页展示。 | 逻辑同上，区别在于过滤 `ReceiveId` 以 'G' 开头的记录，且缓存 Key 为 `group_session_list_`。 |
| `DeleteSession` | 删除某个会话。 | 用户左滑删除聊天窗口。 | 1. **软删除**：调用 Repository 进行软删除。<br>2. **清理缓存**：异步清除用户的会话列表缓存。 |

---

## 3. 核心数据模型 (Core Data Models)

### 3.1 数据库实体 (Database Entity)

**源文件**: `internal/model/session.go`
**表名**: `session`

| 字段名 | 类型 | 说明 | 关键实现细节 |
| :--- | :--- | :--- | :--- |
| `Uuid` | `string` | 会话唯一标识 | 以 "S" 开头，用于操作特定会话。 |
| `SendId` | `string` | 会话所有者 ID | **注意**: 会话是**单向**的。A 和 B 聊天，数据库存两条记录：A 的会话(SendId=A, ReceiveId=B) 和 B 的会话(SendId=B, ReceiveId=A)。这样双方可以独立删除或置顶会话。 |
| `ReceiveId` | `string` | 会话目标 ID | 对方的用户 ID 或 群组 ID。 |
| `ReceiveName` | `string` | 目标名称快照 | 冗余存储，避免联表查询。 |
| `Avatar` | `string` | 目标头像快照 | 冗余存储，避免联表查询。 |
| `LastMessage` | `string` | 最后一条消息预览 | 暂时保留字段，部分场景用于列表展示。 |

### 3.2 关键 DTO

*   **CreateSessionRequest**:
    ```go
    type CreateSessionRequest struct {
        SendId    string // 发起人
        ReceiveId string // 接收人（用户或群）
    }
    ```
*   **UserSessionListRespond**:
    ```go
    type UserSessionListRespond struct {
        SessionId string 
        Avatar    string 
        UserId    string // 对方ID
        Username  string // 对方名称
    }
    ```

---

## 4. 全局实现核心 (The Core of Implementation)

### 4.1 核心设计模式：单向会话 (Unidirectional Session)
*   **设计**: 这是 IM 系统中至关重要的设计。会话关系是**属于用户**的，而不是属于两个人的。
*   **体现**:
    *   A 给 B 发消息，系统会确保 `Session{Send: A, Recv: B}` 和 `Session{Send: B, Recv: A}` 都存在。
    *   删除时，A 只能删除 `CheckOpenSessionAllowed` 自己的那条记录，不影响 B 的列表。
    *   `SendId` 实际上表示“该会话列表的所有者”。

### 4.2 缓存与一致性
*   **缓存粒度**:
    1.  **单个会话缓存**: `session_sendId_recvId`，用于精准查找。
    2.  **列表缓存**: `direct_session_list_uid` 和 `group_session_list_uid`，缓存整个列表。
*   **更新策略**:
    *   **Cache-Aside**: 读的时候 Miss 则查库回填。
    *   **主动失效**: `CreateSession` 和 `DeleteSession` 会调用 `clearSessionCacheForUser` 主动删除列表缓存，保证列表的最终一致性。

### 4.3 异构 ID 处理
*   **逻辑**: 会话表中不区分 `User` 和 `Group` 字段，而是统一使用 `ReceiveId`。
*   **区分方式**: 依靠 ID 前缀。
    *   `UserId` 格式: `U` + 随机串。
    *   `GroupId` 格式: `G` + 随机串。
*   **代码体现**: 在 `GetUserSessionList` 和 `GetGroupSessionList`中，通过 `if ReceiveId[0] == 'U'` 或 `'G'` 来手动分拣数据。

### 4.4 潜在优化点
*   **快照更新问题**: `Session` 表冗余了 `Avatar` 和 `ReceiveName`。如果对方修改了头像或昵称，当前逻辑可能不会实时更新会话表中的字段，导致会话列表显示旧信息。通常需要在用户/群组信息更新时，异步同步更新相关的 `Session` 记录，或者改为前端根据 ID 再次拉取最新详情。
