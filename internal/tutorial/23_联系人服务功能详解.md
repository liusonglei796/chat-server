# Contact Service 功能详解文档

本文档详细说明了 `internal/service/contact/service.go` 中各个核心方法的设计目的、应用场景及内部逻辑。

## 1. GetUserList
**函数签名**: `GetUserList(userId string) ([]respond.MyUserListRespond, error)`

*   **核心目的**: 获取用户的“好友通讯录”。
*   **应用场景**: 
    *   用户点击 App底部的“通讯录”标签页。
    *   发起私聊或群聊邀请时展示的好友选择列表。
*   **逻辑过程**:
    1.  **查询缓存**: 尝试从 Redis Set (`contact_relation:user:<uid>`) 获取好友 ID 列表。
    2.  **缓存回源 (Cache Miss)**: 若缓存为空，查询 MySQL `contact` 表 (`type=USER`) 获取 ID，并回写 Redis Set。
    3.  **批量聚合**: 根据获取的 IDs，调用 `UserRepo.FindByUuids` 批量查询用户的具体资料（昵称、头像）。
    4.  **组装返回**: 将 ID 和资料组装成前端所需的响应结构。

## 2. GetJoinedGroupsExcludedOwn
**函数签名**: `GetJoinedGroupsExcludedOwn(userId string) ([]respond.LoadMyJoinedGroupRespond, error)`
*(原名 LoadMyJoinedGroup)*

*   **核心目的**: 获取用户加入的、但非自己创建的群组列表。
*   **应用场景**: 
    *   通讯录页面的“群组”列表展示（通常“我创建的”和“我加入的”会分开展示或通过标签区分）。
*   **逻辑过程**:
    1.  **查询缓存**: 尝试从 Redis Set (`contact_relation:group:<uid>`) 获取群组 ID 列表。
    2.  **缓存回源**: 若缓存为空，查询 MySQL `contact` 表 (`type=GROUP`) 获取 ID，并回写 Redis Set。
    3.  **批量聚合**: 调用 `GroupRepo.FindByUuids` 批量查询群组详情。
    4.  **过滤逻辑**: 遍历群组列表，**剔除** `OwnerId == CurrentUserId` 的群组。
    5.  **组装返回**: 返回剩余的群组列表。

## 3. GetContactInfo
**函数签名**: `GetContactInfo(contactId string) (respond.GetContactInfoRespond, error)`

*   **核心目的**: 获取任意联系人（用户或群组）的基础详情。
*   **应用场景**: 
    *   点击会话列表中的头像。
    *   点击通讯录中的某一行。
    *   展示“个人名片”或“群名片”。
*   **逻辑过程**:
    1.  **类型判断**: 根据 ID 前缀 (`U` vs `G`) 决定后续流程。
    2.  **二级缓存**: 
        *   若为群：查 `group_info_<id>`。
        *   若为人：查 `user_info_<id>`。
    3.  **数据库查询**: 若缓存未命中，分别查询 `Group` 表或 `User` 表。
    4.  **状态校验**: 检查用户/群组是否被禁用 (Status Check)。
    5.  **回写与返回**: 将结果存入 Redis 并返回统一的 `GetContactInfoRespond` 结构。

## 4. DeleteContact
**函数签名**: `DeleteContact(userId, contactId string) error`

*   **核心目的**: 解除好友关系或退出群聊（视具体业务定义，目前代码主要支撑删除好友）。
*   **应用场景**: 
    *   好友详情页 -> “删除好友”。
*   **逻辑过程**:
    1.  **开启事务**: 确保数据一致性。
    2.  **软删除联系**: 在 `contact` 表中软删除 A->B 的记录（注：根据实现通常是单向删除及会话）。
    3.  **软删除会话**: 删除 A 与 B 的聊天 Session。
    4.  **软删除申请**: 清理历史申请记录，防止脏数据。
    5.  **提交事务**: 确认变更。
    6.  **异步清理 Redis**: 删除 `contact_user_list` 和 `direct_session_list` 缓存，强制前端下次拉取最新数据。

## 5. ApplyContact
**函数签名**: `ApplyContact(req request.ApplyContactRequest) error`

*   **核心目的**: 发起添加好友或入群的申请。
*   **应用场景**: 
    *   通过搜索找到用户/群组，点击“添加到通讯录”。
*   **逻辑过程**:
    1.  **前置校验**: 验证目标 ID 有效性、是否存在、是否被禁用。
    2.  **重复关系检查**: 检查是否已经是好友或群成员，若是则直接报错提示。
    3.  **查询旧申请**: 检查是否之前申请过。
        *   若无：**创建**一条新的 `PENDING` 记录。
        *   若有：**更新**旧记录的状态为 `PENDING`，并更新留言和时间。
    4.  **黑名单检查**: 若曾经被对方拉黑申请 (`Status=BLACK`)，则拦截请求。

## 6. GetNewContactList
**函数签名**: `GetNewContactList(userId string) ([]respond.NewContactListRespond, error)`

*   **核心目的**: 获取此用户收到的所有待处理（及历史）好友申请。
*   **应用场景**: 
    *   App “新的朋友”页面。
    *   展示红点未读数。
*   **逻辑过程**:
    1.  **查询申请**: 查 `contact_apply` 表，条件 `TargetId = Me` 且 `Status = PENDING` (通常)。
    2.  **批量聚合**: 提取所有 `ApplicantId`，批量查询这些申请人的头像和昵称。
    3.  **组装返回**: 将申请附带的留言 (`Message`) 与申请人资料合并返回。

## 7. PassApply
**函数签名**: `PassApply(targetId string, applicantId string) error`

*   **核心目的**: 接受对方的好友申请或入群申请。
*   **应用场景**: 
    *   在“新的朋友”页面点击“同意”。
*   **逻辑过程**:
    1.  **开启事务**。
    2.  **更新申请状态**: 将 `contact_apply` 记录标记为 `AGREE`。
    3.  **分支处理**:
        *   **好友申请**: 
            *   创建 **双向** `Contact` 记录 (A->B 和 B->A)。
        *   **入群申请**:
            *   创建 `Contact` (User->Group)。
            *   创建 `GroupMember` 记录。
            *   群成员计数 +1。
    4.  **提交事务**。
    5.  **异步清理缓存**: 清理双方的联系人列表缓存、群成员列表缓存等。

## 8. RefuseApply
**函数签名**: `RefuseApply(targetId string, applicantId string) error`

*   **核心目的**: 拒绝申请。
*   **应用场景**: 
    *   在“新的朋友”页面点击“拒绝”。
*   **逻辑过程**:
    *   简单地将 `contact_apply` 表中对应的记录状态更新为 `REFUSE`。

## 9. BlackContact
**函数签名**: `BlackContact(userId string, contactId string) error`

*   **核心目的**: 将好友加入黑名单。
*   **应用场景**: 
    *   用户详情页 -> 更多 -> “加入黑名单”。
*   **逻辑过程**:
    1.  **开启事务**。
    2.  **双向更新状态**: 
        *   我这边记录更新为 `BLACK` (拉黑)。
        *   对方那边记录更新为 `BE_BLACK` (被拉黑)。
    3.  **删除会话**: 软删除双方的 Session，切断聊天入口。
    4.  **提交事务**。
    5.  **缓存清理**: 清理双方列表缓存。

## 10. CancelBlackContact
**函数签名**: `CancelBlackContact(userId string, contactId string) error`

*   **核心目的**: 移出黑名单。
*   **应用场景**: 
    *   设置 -> 隐私 -> 黑名单列表 -> 点击移除。
*   **逻辑过程**:
    1.  **状态校验**: 确认通过确实处于拉黑状态。
    2.  **开启事务**。
    3.  **状态恢复**: 将双方的 `Contact` 状态全部重置为 `NORMAL`（恢复好友关系）。
    4.  **异步清理缓存**: 触发列表重新加载。

## 11. GetAddGroupList
**函数签名**: `GetAddGroupList(groupId string) ([]respond.AddGroupListRespond, error)`

*   **核心目的**: 群主/管理员查看入群申请。
*   **应用场景**: 
    *   群聊设置 -> “入群申请”。
*   **逻辑过程**:
    *   逻辑与 `GetNewContactList` 完全一致，只是查询条件变为 `TargetId = GroupId`。

## 12. BlackApply
**函数签名**: `BlackApply(targetId string, applicantId string) error`

*   **核心目的**: 屏蔽某人的申请（拉黑申请，而非拉黑用户）。
*   **应用场景**: 
    *   面对骚扰申请，彻底屏蔽，使其无法再次发起申请。
*   **逻辑过程**:
    *   将 `contact_apply` 记录的状态更新为 `BLACK`。这也解释了 `ApplyContact` 中为何会检查此状态。
